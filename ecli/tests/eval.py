import json
from multiprocessing import process
import os
import re
import subprocess
from typing import List, TypedDict
from langchain.chains.conversation.memory import ConversationBufferMemory
from langchain.chat_models import ChatOpenAI
from langchain.chains import ConversationChain

class CommandResult(TypedDict):
    command: str
    stdout: str
    stderr: str
    returncode: int

def run_command(command: List[str]) -> CommandResult:
    # Start the process
    with subprocess.Popen(command,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          text=True,
                          ) as process:
        stdout = ""
        stderr = ""
        try:
            # Set a timer to kill the process if it doesn't finish within the timeout
            while process.poll() is None:
                # Only try to read output if the process is still running
                if process.stdout.readable():
                    line = process.stdout.read()
                    print(line, end='')
                    stdout += line
            # Wait for the process to finish and get the output
            last_stdout, last_stderr = process.communicate()
            stdout += last_stdout
            stderr += last_stderr
        except Exception as e:
            print("Exception: " + str(e))
        finally:
            # Make sure the timer is canceled
            if process.poll() is None and process.stdout.readable():
                stdout += process.stdout.read()
                print(stdout)
            if process.poll() is None and process.stderr.readable():
                stderr += process.stderr.read()
                print(stderr)
            return {
                "command": ' '.join(command),
                "stdout": stdout,
                "stderr": stderr,
                "returncode": process.returncode
            }
        
def test_ecli(request, max_iterations=5):
    example = """
    /* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
    #define BPF_NO_GLOBAL_DATA
    #include <linux/bpf.h>
    #include <bpf/bpf_helpers.h>
    #include <bpf/bpf_tracing.h>

    typedef unsigned int u32;
    typedef int pid_t;
    const pid_t pid_filter = 0;

    char LICENSE[] SEC("license") = "Dual BSD/GPL";

    SEC("tp/syscalls/sys_enter_write")
    int handle_tp(void* ctx) {
        pid_t pid = bpf_get_current_pid_tgid() >> 32;
        if (pid_filter && pid != pid_filter)
            return 0;
        bpf_printk("BPF triggered from PID %d.\n", pid);
        return 0;
    }
    """

    PROMPT = f"""
    Generate an eBPF C language program to achieve the following task: {request}. Please include the necessary eBPF hooks, maps, and functions.
    This is a minimal example of eBPF code:
    {example}
    PLEASE REPLY WITH THE CODE DIRECTLY AND DO NOT INCLUDE ANY ADDITIONAL INFORMATION.
    """

    # init the chain
    llm = ChatOpenAI(model_name="gpt-3.5-turbo-16k", temperature=0)
    agent_chain = ConversationChain(llm=llm, verbose=False, memory=ConversationBufferMemory())
    response = agent_chain.predict(input=PROMPT)

    # set the path for test
    test_directory = f"{os.path.dirname(__file__)}/test/{os.getpid()}"
    os.makedirs(test_directory)
    ebpf_prog_file = f"{test_directory}/ebpf_prog_{os.getpid()}.bpf.c"
    chat_history_file = f"{test_directory}/logs_{os.getpid()}.txt"

    # try compile ebpf file generated by GPT
    compile_success = False
    for _ in range(max_iterations):
        pattern = r'```[^\n]*\n(.*?)```'
        code_blocks = re.findall(pattern, response, re.DOTALL)
        if code_blocks == ['']:
            code_blocks = response
        with open(ebpf_prog_file, "w", encoding='utf-8') as file:
            file.write("\n".join(code_blocks))
        cmd = ["ecc", ebpf_prog_file, "-o", test_directory]
        ret = run_command(cmd)
        if ret["returncode"] == 0:
            compile_success = True
            break
        else:
            stderr = ret["stderr"]
            PROMPT_FOR_ERR = f"""
            While compiling a BPF program, the following error has occurred.
                {stderr}
            Please correct the code based on the error message and return the corrected code."""
            response = agent_chain.predict(input=PROMPT_FOR_ERR)

    # test the compile result
    ecli_test_result = ""
    if compile_success:
        package_path = f"{test_directory}/package.json"
        cmd = ["ecli", package_path]
        ret = run_command(cmd)
        ecli_test_result = ret["stdout"] if ret["returncode"] == 0 else ret["stderr"]

    # save the chat history
    with open(chat_history_file, "a+", encoding="utf-8") as file:
        history = "\n".join([message.content for message in agent_chain.memory.chat_memory.messages])
        file.write(history)
        file.write(ecli_test_result)
    print(f"Output will be saved to: {ebpf_prog_file} and {chat_history_file}")

def main():
    with open('cases.txt', 'r') as file:
        lines = file.readlines()
        for i, line in enumerate(lines):
            line = line.strip()  # Remove the newline character at the end
            print(f"Running {i}-th test case: {line}")
            test_ecli(line)

if __name__ == "__main__":
    main()
    # test_ecli("Write a BPF code that traces TCP connection resets and logs the source and destination IP addresses.")
