<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>在 WebAssembly 中使用 Rust 编写 eBPF 程序并发布 OCI 镜像 - Eunomia-bpf Documents</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../introduction/introduction.html"><strong aria-hidden="true">1.1.</strong> Detail introduction</a></li><li class="chapter-item "><a href="../wasm-bpf.html"><strong aria-hidden="true">1.2.</strong> Wasm-bpf subproject</a></li></ol></li><li class="chapter-item "><li class="part-title">User Manual</li><li class="chapter-item "><a href="../quickstart.html"><strong aria-hidden="true">2.</strong> Quick Start</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../installation/index.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item "><a href="../installation/build.html"><strong aria-hidden="true">2.2.</strong> Build</a></li><li class="chapter-item "><a href="../installation/build-android-arm.html"><strong aria-hidden="true">2.3.</strong> Build on Android or ARM</a></li></ol></li><li class="chapter-item "><a href="../ecc/index.html"><strong aria-hidden="true">3.</strong> ecc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ecc/usage.html"><strong aria-hidden="true">3.1.</strong> usage</a></li><li class="chapter-item "><a href="../ecc/docker-usage.html"><strong aria-hidden="true">3.2.</strong> docker</a></li><li class="chapter-item "><a href="../ecc/github-template.html"><strong aria-hidden="true">3.3.</strong> template</a></li><li class="chapter-item "><a href="../ecc/config-lua-depreciate.html"><strong aria-hidden="true">3.4.</strong> lua</a></li></ol></li><li class="chapter-item "><a href="../ecli/index.html"><strong aria-hidden="true">4.</strong> ecli</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ecli/docker.html"><strong aria-hidden="true">4.1.</strong> docker</a></li></ol></li><li class="chapter-item "><a href="../ecli-dockerfile-usage.html"><strong aria-hidden="true">5.</strong> Docker manual</a></li><li class="chapter-item "><a href="../manual.html"><strong aria-hidden="true">6.</strong> Manual (Chinese)</a></li><li class="chapter-item "><a href="../online.html"><strong aria-hidden="true">7.</strong> Online Demo</a></li><li class="chapter-item "><a href="../common_problems.html"><strong aria-hidden="true">8.</strong> Common problems</a></li><li class="chapter-item "><a href="../supporting-external-BTF.html"><strong aria-hidden="true">9.</strong> External BTF support</a></li><li class="chapter-item "><a href="../benchmark.html"><strong aria-hidden="true">10.</strong> Benchmark</a></li><li class="chapter-item affix "><li class="part-title">Videos</li><li class="chapter-item "><a href="../video.html"><strong aria-hidden="true">11.</strong> Public talk video</a></li><li class="chapter-item affix "><li class="part-title">Blogs</li><li class="chapter-item expanded "><a href="../blog/index.html"><strong aria-hidden="true">12.</strong> Blogs (Chinese)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../blog/introduce-to-wasm-bpf-bpf-community.html"><strong aria-hidden="true">12.1.</strong> Wasm-bpf: 架起 Webassembly 和 eBPF 内核可编程的桥梁</a></li><li class="chapter-item "><a href="../blog/how-to-write-c-in-wasm.html"><strong aria-hidden="true">12.2.</strong> 在 WebAssembly 中使用 C/C++ 和 libbpf 编写 eBPF 程序</a></li><li class="chapter-item expanded "><a href="../blog/how-to-write-rust-in-wasm.html" class="active"><strong aria-hidden="true">12.3.</strong> 在 WebAssembly 中使用 Rust 编写 eBPF 程序并发布 OCI 镜像</a></li><li class="chapter-item "><a href="../blog/GPTtrace.html"><strong aria-hidden="true">12.4.</strong> 使用 ChatGPT ，通过自然语言编写 eBPF 程序和追踪 Linux 系统</a></li><li class="chapter-item "><a href="../blog/ebpf-wasm.html"><strong aria-hidden="true">12.5.</strong> 当 Wasm 遇见 eBPF ：使用 WebAssembly 编写、分发、加载运行 eBPF 程序</a></li><li class="chapter-item "><a href="../blog/lmp-eunomia.html"><strong aria-hidden="true">12.6.</strong> 如何在 Linux 显微镜（LMP）项目中开启 eBPF 之旅</a></li><li class="chapter-item "><a href="../blog/0.3.0-release.html"><strong aria-hidden="true">12.7.</strong> eunomia-bpf 0.3.0 发布：只需编写内核态代码，轻松构建、打包、发布完整的 eBPF 应用</a></li><li class="chapter-item "><a href="../blog/coolbpf-eunomia.html"><strong aria-hidden="true">12.8.</strong> eunomia-bpf：展望 2023，让 eBPF 插上 Wasm 的翅膀</a></li><li class="chapter-item "><a href="../blog/bpf-news.html"><strong aria-hidden="true">12.9.</strong> eBPF 进阶: 内核新特性进展一览</a></li><li class="chapter-item "><a href="../blog/test-for-Android.html"><strong aria-hidden="true">12.10.</strong> ecli 在安卓 13 上的运行测试</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Eunomia-bpf Documents</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/eunomia-bpf/eunomia-bpf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="在-webassembly-中使用-rust-编写-ebpf-程序并发布-oci-镜像"><a class="header" href="#在-webassembly-中使用-rust-编写-ebpf-程序并发布-oci-镜像">在 WebAssembly 中使用 Rust 编写 eBPF 程序并发布 OCI 镜像</a></h1>
<blockquote>
<p>作者：于桐，郑昱笙</p>
</blockquote>
<p>eBPF（extended Berkeley Packet Filter）是一种高性能的内核虚拟机，可以运行在内核空间中，以收集系统和网络信息。随着计算机技术的不断发展，eBPF 的功能日益强大，并且已经成为各种效率高效的在线诊断和跟踪系统，以及构建安全的网络、服务网格的重要组成部分。</p>
<p>WebAssembly（Wasm）最初是以浏览器安全沙盒为目的开发的，发展到目前为止，WebAssembly 已经成为一个用于云原生软件组件的高性能、跨平台和多语言软件沙箱环境，Wasm 轻量级容器也非常适合作为下一代无服务器平台运行时，或在边缘计算等资源受限的场景高效执行。</p>
<p>现在，借助 Wasm-bpf 编译工具链和运行时，我们可以使用 Wasm 将 eBPF 程序编写为跨平台的模块，使用 C/C++ 和 Rust 编写程序。通过在 WebAssembly 中使用 eBPF 程序，我们不仅让 Wasm 应用获得 eBPF 的高性能、对系统接口的访问能力，还可以让 eBPF 程序享受到 Wasm 的沙箱、灵活性、跨平台性、和动态加载的能力，并且使用 Wasm 的 OCI 镜像来方便、快捷地分发和管理 eBPF 程序。例如，可以类似 docker 一样，从云端一行命令获取 Wasm 轻量级容器镜像，并运行任意 eBPF 程序。通过结合这两种技术，我们将会给 eBPF 和 Wasm 生态来一个全新的开发体验！</p>
<h2 id="使用-wasm-bpf-工具链在-wasm-中编写动态加载分发运行-ebpf-程序"><a class="header" href="#使用-wasm-bpf-工具链在-wasm-中编写动态加载分发运行-ebpf-程序">使用 Wasm-bpf 工具链在 Wasm 中编写、动态加载、分发运行 eBPF 程序</a></h2>
<p>在前两篇短文中，我们已经介绍了 Wasm-bpf 的设计思路，以及如何使用 C/C++ 在 Wasm 中编写 eBPF 程序:</p>
<ul>
<li>Wasm-bpf: 架起 Webassembly 和 eBPF 内核可编程的桥梁: <a href="https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew">https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</a></li>
<li>在 WebAssembly 中使用 C/C++ 和 libbpf 编写 eBPF 程序: <a href="https://zhuanlan.zhihu.com/p/605542090">https://zhuanlan.zhihu.com/p/605542090</a></li>
</ul>
<p>基于 Wasm，我们可以使用多种语言构建 eBPF 应用，并以统一、轻量级的方式管理和发布。以我们构建的示例应用 bootstrap.wasm 为例，使用 C/C++ 构建的镜像大小最小仅为 ~90K，很容易通过网络分发，并可以在不到 100ms 的时间内在另一台机器上动态部署、加载和运行，并且保留轻量级容器的隔离特性。运行时不需要内核特定版本头文件、LLVM、clang 等依赖，也不需要做任何消耗资源的重量级的编译工作。对于 Rust 而言，编译产物会稍大一点，大约在 2M 左右。</p>
<p>本文将以 Rust 语言为例，讨论：</p>
<ul>
<li>使用 Rust 编写 eBPF 程序并编译为 Wasm 模块</li>
<li>使用 OCI 镜像发布、部署、管理 eBPF 程序，获得类似 Docker 的体验</li>
</ul>
<p>我们在仓库中提供了几个示例程序，分别对应于可观测、网络、安全等多种场景。</p>
<h2 id="编写-ebpf-程序并编译为-wasm-的大致流程"><a class="header" href="#编写-ebpf-程序并编译为-wasm-的大致流程">编写 eBPF 程序并编译为 Wasm 的大致流程</a></h2>
<p>一般说来，在非 Wasm 沙箱的用户态空间，使用 libbpf-bootstrap 脚手架，可以快速、轻松地使用 C/C++构建 BPF 应用程序。编译、构建和运行 eBPF 程序（无论是采用什么语言），通常包含以下几个步骤：</p>
<ul>
<li>编写内核态 eBPF 程序的代码，一般使用 C/C++ 或 Rust 语言</li>
<li>使用 clang 编译器或者相关工具链编译 eBPF 程序（要实现跨内核版本移植的话，需要包含 BTF 信息）。</li>
<li>在用户态的开发程序中，编写对应的加载、控制、挂载、数据处理逻辑；</li>
<li>在实际运行的阶段，从用户态将 eBPF 程序加载进入内核，并实际执行。</li>
</ul>
<h2 id="使用-rust-编写-ebpf-程序并编译为-wasm"><a class="header" href="#使用-rust-编写-ebpf-程序并编译为-wasm">使用 Rust 编写 eBPF 程序并编译为 Wasm</a></h2>
<p>Rust 可能是 WebAssembly 生态系统中支持最好的语言。Rust 不仅支持几个 WebAssembly 编译目标，而且 wasmtime、Spin、Wagi 和其他许多 WebAssembly 工具都是用 Rust 编写的。因此，我们也提供了 Rust 的开发示例：</p>
<ul>
<li>Wasm 和 WASI 的 Rust 生态系统非常棒</li>
<li>许多 Wasm 工具都是用 Rust 编写的，这意味着有大量的代码可以复用。</li>
<li>Spin 通常在对其他语言的支持之前就有Rust的功能支持</li>
<li>Wasmtime 是用 Rust编写的，通常在其他运行时之前就有最先进的功能。</li>
<li>可以在 WebAssembly 中使用许多现成的 Rust 库。</li>
<li>由于 Cargo 的灵活构建系统，一些 Crates 甚至有特殊的功能标志来启用Wasm的功能（例如Chrono）。</li>
<li>由于 Rust 的内存管理技术，与同类语言相比，Rust 的二进制大小很小。</li>
</ul>
<p>我们同样提供了一个 Rust 的 eBPF SDK，可以使用 Rust 编写 eBPF 的用户态程序并编译为 Wasm。借助 aya-rs 提供的相关工具链支持，内核态的 eBPF 程序也可以用 Rust 进行编写，不过在这里，我们还是复用之前使用 C 语言编写的内核态程序。</p>
<p>首先，我们需要使用 rust 提供的 wasi 工具链，创建一个新的项目：</p>
<pre><code class="language-sh">rustup target add wasm32-wasi
cargo new rust-helloworld
</code></pre>
<p>之后，可以使用 <code>Makefile</code> 运行 make 完成整个编译流程，并生成 <code>bootstrap.bpf.o</code> eBPF 字节码文件。</p>
<h3 id="使用-wit-bindgen-生成类型信息用于内核态和-wasm-模块之间通信"><a class="header" href="#使用-wit-bindgen-生成类型信息用于内核态和-wasm-模块之间通信">使用 wit-bindgen 生成类型信息，用于内核态和 Wasm 模块之间通信</a></h3>
<p>wit-bindgen 项目是一套着眼于 WebAssembly，并使用组件模型的语言的绑定生成器。绑定是用 *.wit 文件描述的，文件中描述了 Wasm 模块导入、导出的函数和接口。我们可以 wit-bindgen 它来生成多种语言的类型定义，以便在内核态的 eBPF 和用户态的 Wasm 模块之间传递数据。</p>
<p>我们首先需要在 <code>Cargo.toml</code> 配置文件中加入 <code>wasm-bpf-binding</code> 和 <code>wit-bindgen-guest-rust</code> 依赖：</p>
<pre><code class="language-toml">wasm-bpf-binding = { path = &quot;wasm-bpf-binding&quot; }
</code></pre>
<p>这个包提供了 wasm-bpf 由运行时提供给 Wasm 模块，用于加载和控制 eBPF 程序的函数的绑定。</p>
<ul>
<li><code>wasm-bpf-binding</code> 在 wasm-bpf 仓库中有提供。</li>
</ul>
<pre><code class="language-toml">[dependencies]
wit-bindgen-guest-rust = { git = &quot;https://github.com/bytecodealliance/wit-bindgen&quot;, version = &quot;0.3.0&quot; }

[patch.crates-io]
wit-component = {git = &quot;https://github.com/bytecodealliance/wasm-tools&quot;, version = &quot;0.5.0&quot;, rev = &quot;9640d187a73a516c42b532cf2a10ba5403df5946&quot;}
wit-parser = {git = &quot;https://github.com/bytecodealliance/wasm-tools&quot;, version = &quot;0.5.0&quot;, rev = &quot;9640d187a73a516c42b532cf2a10ba5403df5946&quot;}
</code></pre>
<p>这个包支持用 wit 文件为 rust 客户程序生成绑定。使用这个包的情况下，我们不需要再手动运行 wit-bindgen。</p>
<p>接下来，我们使用 <code>btf2wit</code> 工具，从 BTF 信息生成 wit 文件。可以使用 <code>cargo install btf2wit</code> 安装我们提供的 btf2wit 工具，并编译生成 wit 信息：</p>
<pre><code class="language-console">cd btf
clang -target bpf -g event-def.c -c -o event.def.o
btf2wit event.def.o -o event-def.wit
cp *.wit ../wit/
</code></pre>
<ul>
<li>其中 <code>event-def.c</code> 是包含了我们需要的结构体信息的的 C 程序文件。只有在导出符号中用到的结构体才会被记录在 BTF 中。</li>
</ul>
<p>对于 C 结构体生成的 wit 信息，大致如下：</p>
<pre><code class="language-wit">default world host {
    record event {
         pid: s32,
        ppid: s32,
        exit-code: u32,
        --pad0: list&lt;s8&gt;,
        duration-ns: u64,
        comm: list&lt;s8&gt;,
        filename: list&lt;s8&gt;,
        exit-event: s8,
    }
}
</code></pre>
<p><code>wit-bindgen-guest-rust</code> 会为 wit 文件夹中的所有类型信息，自动生成 rust 的类型，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
struct Event {
    pid: i32,
    ppid: i32,
    exit_code: u32,
    __pad0: [u8; 4],
    duration_ns: u64,
    comm: [u8; 16],
    filename: [u8; 127],
    exit_event: u8,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="编写用户态加载和处理代码"><a class="header" href="#编写用户态加载和处理代码">编写用户态加载和处理代码</a></h3>
<p>为了在 WASI 上运行，需要为 main.rs 添加 <code>#![no_main]</code> 属性，并且 main 函数需要采用类似如下的形态：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name = &quot;__main_argc_argv&quot;]
fn exam_main(_env_json: u32, _str_len: i32) -&gt; i32 {

    return 0;
}
<span class="boring">}</span></code></pre></pre>
<p>用户态加载和挂载代码，和 C/C++ 中类似：</p>
<pre><code class="language-rust ignore">    let obj_ptr =
        binding::wasm_load_bpf_object(bpf_object.as_ptr() as u32, bpf_object.len() as i32);
    if obj_ptr == 0 {
        println!(&quot;Failed to load bpf object&quot;);
        return 1;
    }
    let attach_result = binding::wasm_attach_bpf_program(
        obj_ptr,
        &quot;handle_exec\0&quot;.as_ptr() as u32,
        &quot;\0&quot;.as_ptr() as u32,
    );
    ..</code></pre>
<p>polling ring buffer：</p>
<pre><code class="language-rust ignore">    let map_fd = binding::wasm_bpf_map_fd_by_name(obj_ptr, &quot;rb\0&quot;.as_ptr() as u32);
    if map_fd &lt; 0 {
        println!(&quot;Failed to get map fd: {}&quot;, map_fd);
        return 1;
    }
    // binding::wasm
    let buffer = [0u8; 256];
    loop {
        // polling the buffer
        binding::wasm_bpf_buffer_poll(
            obj_ptr,
            map_fd,
            handle_event as i32,
            0,
            buffer.as_ptr() as u32,
            buffer.len() as i32,
            100,
        );
    }</code></pre>
<p>使用 handler 接收返回值：</p>
<pre><code class="language-rust ignore">
extern &quot;C&quot; fn handle_event(_ctx: u32, data: u32, _data_sz: u32) {
    let event_slice = unsafe { slice::from_raw_parts(data as *const Event, 1) };
    let event = &amp;event_slice[0];
    let pid = event.pid;
    let ppid = event.ppid;
    let exit_code = event.exit_code;
    if event.exit_event == 1 {
        print!(
            &quot;{:&lt;8} {:&lt;5} {:&lt;16} {:&lt;7} {:&lt;7} [{}]&quot;,
            &quot;TIME&quot;,
            &quot;EXIT&quot;,
            unsafe { CStr::from_ptr(event.comm.as_ptr() as *const i8) }
                .to_str()
                .unwrap(),
            pid,
            ppid,
            exit_code
        );
        ..
}</code></pre>
<p>接下来即可使用 cargo 编译运行：</p>
<pre><code class="language-console">$ cargo build --target wasi32-wasm
$ sudo wasm-bpf ./target/wasm32-wasi/debug/rust-helloworld.wasm
TIME     EXEC  sh               180245  33666   /bin/sh
TIME     EXEC  which            180246  180245  /usr/bin/which
TIME     EXIT  which            180246  180245  [0] (1ms)
TIME     EXIT  sh               180245  33666   [0] (3ms)
TIME     EXEC  sh               180247  33666   /bin/sh
TIME     EXEC  ps               180248  180247  /usr/bin/ps
TIME     EXIT  ps               180248  180247  [0] (23ms)
TIME     EXIT  sh               180247  33666   [0] (25ms)
TIME     EXEC  sh               180249  33666   /bin/sh
TIME     EXEC  cpuUsage.sh      180250  180249  /root/.vscode-server-insiders/bin/a7d49b0f35f50e460835a55d20a00a735d1665a3/out/vs/base/node/cpuUsage.sh
</code></pre>
<h2 id="使用-oci-镜像发布和管理-ebpf-程序"><a class="header" href="#使用-oci-镜像发布和管理-ebpf-程序">使用 OCI 镜像发布和管理 eBPF 程序</a></h2>
<p>开放容器协议 (OCI) 是一个轻量级，开放的治理结构，为容器技术定义了规范和标准。在 Linux 基金会的支持下成立，由各大软件企业构成，致力于围绕容器格式和运行时创建开放的行业标准。其中包括了使用 Container Registries 进行工作的 API，正式名称为 OCI 分发规范 (又名“distribution-spec”)。</p>
<p>Docker 也宣布推出与 WebAssembly 集成 (Docker+Wasm) 的首个技术预览版，并表示公司已加入字节码联盟 (Bytecode Alliance)，成为投票成员。Docker+Wasm 让开发者能够更容易地快速构建面向 Wasm 运行时的应用程序。</p>
<p>借助于 Wasm 的相关生态，可以非常方便地发布、下载和管理 eBPF 程序，例如，使用 <code>wasm-to-oci</code> 工具，可以将 Wasm 程序打包为 OCI 镜像，获取类似 docker 的体验：</p>
<pre><code class="language-console">wasm-to-oci push testdata/hello.wasm &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1
wasm-to-oci pull &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1 --out test.wasm
</code></pre>
<p>我们也将其集成到了 eunomia-bpf 的 ecli 工具中，可以一行命令从云端的 Github Packages 中下载并运行 eBPF 程序，或通过 Github Packages 发布：</p>
<pre><code class="language-bash"># push to Github Packages
ecli push https://ghcr.io/eunomia-bpf/sigsnoop:latest
# pull from Github Packages
ecli pull https://ghcr.io/eunomia-bpf/sigsnoop:latest
# run eBPF program
ecli run https://ghcr.io/eunomia-bpf/sigsnoop:latest
</code></pre>
<p>我们已经在 LMP 项目的 eBPF Hub 中，有一些创建符合 OCI 标准的 Wasm-eBPF 应用程序，并利用 ORAS 简化扩展 eBPF 应用开发，分发、加载、运行能力的尝试[11]，以及基于 Wasm 同时使用多种不同语言开发 eBPF 的用户态数据处理插件的实践。基于最新的 Wasm-bpf 框架，有更多的探索性工作可以继续展开，我们希望尝试构建一个完整的针对 eBPF 和 Wasm 程序的包管理系统，以及更多的可以探索的应用场景。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本文以 Rust 语言为例，讨论了使用 Rust 编写 eBPF 程序并编译为 Wasm 模块以及使用 OCI 镜像发布、部署、管理 eBPF 程序，获得类似 Docker 的体验。更完整的代码，请参考我们的 Github 仓库：<a href="https://github.com/eunomia-bpf/wasm-bpf">https://github.com/eunomia-bpf/wasm-bpf</a>.</p>
<p>接下来，我们会继续完善在 Wasm 中使用多种语言开发和运行 eBPF 程序的体验，提供更完善的示例和用户态开发库/工具链，以及更具体的应用场景。</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li>wasm-bpf Github 开源地址：<a href="https://github.com/eunomia-bpf/wasm-bpf">https://github.com/eunomia-bpf/wasm-bpf</a></li>
<li>什么是 eBPF：<a href="https://ebpf.io/what-is-ebpf">https://ebpf.io/what-is-ebpf</a></li>
<li>WASI-eBPF: <a href="https://github.com/WebAssembly/WASI/issues/513">https://github.com/WebAssembly/WASI/issues/513</a></li>
<li>龙蜥社区 eBPF 技术探索 SIG <a href="https://openanolis.cn/sig/ebpfresearch">https://openanolis.cn/sig/ebpfresearch</a></li>
<li>eunomia-bpf 项目：<a href="https://github.com/eunomia-bpf/eunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a></li>
<li>eunomia-bpf 项目龙蜥 Gitee 镜像：<a href="https://gitee.com/anolis/eunomia">https://gitee.com/anolis/eunomia</a></li>
<li>Wasm-bpf: 架起 Webassembly 和 eBPF 内核可编程的桥梁：<a href="https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew">https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</a></li>
<li>当 Wasm 遇见 eBPF ：使用 WebAssembly 编写、分发、加载运行 eBPF 程序：<a href="https://zhuanlan.zhihu.com/p/573941739">https://zhuanlan.zhihu.com/p/573941739</a></li>
<li>Docker+Wasm技术预览：<a href="https://zhuanlan.zhihu.com/p/583614628">https://zhuanlan.zhihu.com/p/583614628</a></li>
<li>LMP eBPF-Hub: <a href="https://github.com/linuxkerneltravel/lmp">https://github.com/linuxkerneltravel/lmp</a></li>
<li>wasm-to-oci: <a href="https://github.com/engineerd/wasm-to-oci">https://github.com/engineerd/wasm-to-oci</a></li>
<li>btf2wit: <a href="https://github.com/eunomia-bpf/btf2wit">https://github.com/eunomia-bpf/btf2wit</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../blog/how-to-write-c-in-wasm.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../blog/GPTtrace.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../blog/how-to-write-c-in-wasm.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../blog/GPTtrace.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
